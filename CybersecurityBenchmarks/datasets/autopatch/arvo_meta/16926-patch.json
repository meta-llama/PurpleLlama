[
  {
    "filename": "fuzzer/Android.bp",
    "patched_line_numbers": [
    ],
    "patch": "diff --git a/fuzzer/Android.bp b/fuzzer/Android.bp\nnew file mode 100644\nindex 0000000..cb7fa72\n--- /dev/null\n+++ b/fuzzer/Android.bp\n\n@@ -0,0 +1,9 @@\n+cc_fuzz {\n+    name: \"hevc_dec_fuzzer\",\n+    host_supported:true,\n+    srcs: [\n+        \"hevc_dec_fuzzer.cpp\",\n+    ],\n+    static_libs: [\"libhevcdec\"],\n+    shared_libs: [\"liblog\"],\n+}"
  },
  {
    "filename": "fuzzer/hevc_dec_fuzzer.cpp",
    "patched_line_numbers": [
      1,
      2,
      29,
      34,
      39,
      43,
      46,
      52,
      56,
      59,
      64,
      65,
      66,
      67,
      68,
      69,
      71,
      72,
      74,
      75,
      76,
      77,
      79,
      80,
      81,
      82,
      83,
      85,
      86,
      87,
      89,
      90,
      92,
      93,
      94,
      95,
      96,
      99,
      100,
      101,
      104,
      105,
      106,
      107,
      109,
      110,
      111,
      112,
      113,
      114,
      115,
      116,
      117,
      118,
      120,
      121,
      122,
      123,
      124,
      125,
      126,
      127,
      129,
      130,
      131,
      132,
      133,
      134,
      136,
      139,
      141,
      142,
      143,
      144,
      145,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      156,
      157,
      158,
      160,
      161,
      162,
      165,
      166,
      167,
      169,
      170,
      171,
      173,
      176,
      177,
      178,
      180,
      181,
      182,
      183,
      185,
      188,
      189,
      190,
      192,
      193,
      194,
      195,
      196,
      197,
      199,
      202,
      203,
      204,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      215,
      218,
      219,
      220,
      221,
      222,
      227,
      228,
      229,
      231,
      233,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255,
      256,
      257,
      258,
      259,
      260,
      261,
      262,
      264,
      265,
      266,
      267,
      271,
      272,
      274,
      275,
      276,
      277,
      278,
      280,
      281,
      283,
      284,
      285,
      286,
      287,
      288,
      290,
      292,
      297,
      299,
      302,
      315,
      321,
      324,
      331,
      333,
      335,
      337,
      338,
      339,
      341,
      343,
      347,
      353,
      356,
      360,
      367,
      374,
      379,
      384
    ],
    "patch": "diff --git a/fuzzer/hevc_dec_fuzzer.cpp b/fuzzer/hevc_dec_fuzzer.cpp\nnew file mode 100644\nindex 0000000..82b97e6\n--- /dev/null\n+++ b/fuzzer/hevc_dec_fuzzer.cpp\n\n@@ -0,0 +1,388 @@\n+/******************************************************************************\n+ *\n+ * Copyright (C) 2019 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ *****************************************************************************\n+ * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore\n+ */\n+/*\n+ * Fuzzer for libhevc decoder\n+ * ==========================\n+ * Requirements\n+ * --------------\n+ * Requires Clang 6.0 or above (needs to support -fsanitize=fuzzer,\n+ * -fsanitize=fuzzer-no-link)\n+ *\n+\n+ * Steps to build\n+ * --------------\n+ * Clone libhevc repository\n+   $ git clone https://android.googlesource.com/platform/external/libhevc\n+\n+ * Create a directory inside libhevc and change directory\n+   $ cd libhevc\n+   $ mkdir hevc_dec_fuzzer\n+   $ cd hevc_dec_fuzzer/\n+\n+ * Build libavc using cmake.\n+   $ CC=clang CXX=clang++ cmake ../ \\\n+     -DSANITIZE=fuzzer-no-link,address,signed-integer-overflow\n+\n+ * Build libhevcdec\n+   $ make -j32\n+\n+ * Build hevc fuzzer\n+   $ clang++ -std=c++11 -fsanitize=fuzzer,address -I.  -I../ \\\n+   -I../common -I../decoder -Wl,--start-group \\\n+   ../fuzzer/hevc_dec_fuzzer.cpp -o ./hevc_dec_fuzzer \\\n+   ./libhevcdec.a -Wl,--end-group\n+\n+ * create a corpus directory and copy some elementary hevc files there.\n+ * Empty corpus directoy also is acceptable, though not recommended\n+   $ mkdir CORPUS && cp some-files CORPUS\n+\n+ * Run fuzzing:\n+   $ ./hevc_dec_fuzzer CORPUS\n+\n+ * References:\n+ * http://llvm.org/docs/LibFuzzer.html\n+ * https://github.com/google/oss-fuzz\n+ */\n+\n+#include <malloc.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <algorithm>\n+#include <memory>\n+\n+#include \"ihevc_typedefs.h\"\n+#include \"ihevcd_cxa.h\"\n+#include \"iv.h\"\n+#include \"ivd.h\"\n+\n+#define NELEMENTS(x) (sizeof(x) / sizeof(x[0]))\n+#define ivd_api_function ihevcd_cxa_api_function\n+const IV_COLOR_FORMAT_T supportedColorFormats[] = {\n+    IV_YUV_420P,   IV_YUV_420SP_UV, IV_YUV_420SP_VU,\n+    IV_YUV_422ILE, IV_RGB_565,      IV_RGBA_8888};\n+\n+enum {\n+  OFFSET_COLOR_FORMAT = 6,\n+  OFFSET_NUM_CORES,\n+  /* Should be the last entry */\n+  OFFSET_MAX,\n+};\n+\n+const static int kSupportedColorFormats = NELEMENTS(supportedColorFormats);\n+const static int kMaxCores = 4;\n+void *iv_aligned_malloc(void *ctxt, WORD32 alignment, WORD32 size) {\n+  (void)ctxt;\n+  return memalign(alignment, size);\n+}\n+\n+void iv_aligned_free(void *ctxt, void *buf) {\n+  (void)ctxt;\n+  free(buf);\n+}\n+\n+class Codec {\n+ public:\n+  Codec(IV_COLOR_FORMAT_T colorFormat, size_t numCores);\n+  ~Codec();\n+\n+  void createCodec();\n+  void deleteCodec();\n+  void resetCodec();\n+  void setCores();\n+  void allocFrame();\n+  void freeFrame();\n+  void decodeHeader(const uint8_t *data, size_t size);\n+  IV_API_CALL_STATUS_T decodeFrame(const uint8_t *data, size_t size,\n+                                   size_t *bytesConsumed);\n+  void setParams(IVD_VIDEO_DECODE_MODE_T mode);\n+\n+ private:\n+  IV_COLOR_FORMAT_T mColorFormat;\n+  size_t mNumCores;\n+  iv_obj_t *mCodec;\n+  ivd_out_bufdesc_t mOutBufHandle;\n+  uint32_t mWidth;\n+  uint32_t mHeight;\n+};\n+\n+Codec::Codec(IV_COLOR_FORMAT_T colorFormat, size_t numCores) {\n+  mColorFormat = colorFormat;\n+  mNumCores = numCores;\n+  mCodec = nullptr;\n+  mWidth = 0;\n+  mHeight = 0;\n+\n+  memset(&mOutBufHandle, 0, sizeof(mOutBufHandle));\n+}\n+\n+Codec::~Codec() {}\n+\n+void Codec::createCodec() {\n+  IV_API_CALL_STATUS_T ret;\n+  ihevcd_cxa_create_ip_t create_ip;\n+  ihevcd_cxa_create_op_t create_op;\n+  void *fxns = (void *)&ivd_api_function;\n+\n+  create_ip.s_ivd_create_ip_t.e_cmd = IVD_CMD_CREATE;\n+  create_ip.s_ivd_create_ip_t.u4_share_disp_buf = 0;\n+  create_ip.s_ivd_create_ip_t.e_output_format = mColorFormat;\n+  create_ip.s_ivd_create_ip_t.pf_aligned_alloc = iv_aligned_malloc;\n+  create_ip.s_ivd_create_ip_t.pf_aligned_free = iv_aligned_free;\n+  create_ip.s_ivd_create_ip_t.pv_mem_ctxt = NULL;\n+  create_ip.s_ivd_create_ip_t.u4_size = sizeof(ihevcd_cxa_create_ip_t);\n+  create_op.s_ivd_create_op_t.u4_size = sizeof(ihevcd_cxa_create_op_t);\n+\n+  ret = ivd_api_function(NULL, (void *)&create_ip, (void *)&create_op);\n+  if (ret != IV_SUCCESS) {\n+    return;\n+  }\n+  mCodec = (iv_obj_t *)create_op.s_ivd_create_op_t.pv_handle;\n+  mCodec->pv_fxns = fxns;\n+  mCodec->u4_size = sizeof(iv_obj_t);\n+}\n+\n+void Codec::deleteCodec() {\n+  ivd_delete_ip_t delete_ip;\n+  ivd_delete_op_t delete_op;\n+\n+  delete_ip.e_cmd = IVD_CMD_DELETE;\n+  delete_ip.u4_size = sizeof(ivd_delete_ip_t);\n+  delete_op.u4_size = sizeof(ivd_delete_op_t);\n+\n+  ivd_api_function(mCodec, (void *)&delete_ip, (void *)&delete_op);\n+}\n+\n+void Codec::resetCodec() {\n+  ivd_ctl_reset_ip_t s_ctl_ip;\n+  ivd_ctl_reset_op_t s_ctl_op;\n+\n+  s_ctl_ip.e_cmd = IVD_CMD_VIDEO_CTL;\n+  s_ctl_ip.e_sub_cmd = IVD_CMD_CTL_RESET;\n+  s_ctl_ip.u4_size = sizeof(ivd_ctl_reset_ip_t);\n+  s_ctl_op.u4_size = sizeof(ivd_ctl_reset_op_t);\n+\n+  ivd_api_function(mCodec, (void *)&s_ctl_ip, (void *)&s_ctl_op);\n+}\n+\n+void Codec::setCores() {\n+  ihevcd_cxa_ctl_set_num_cores_ip_t s_ctl_ip;\n+  ihevcd_cxa_ctl_set_num_cores_op_t s_ctl_op;\n+\n+  s_ctl_ip.e_cmd = IVD_CMD_VIDEO_CTL;\n+  s_ctl_ip.e_sub_cmd =\n+      (IVD_CONTROL_API_COMMAND_TYPE_T)IHEVCD_CXA_CMD_CTL_SET_NUM_CORES;\n+  s_ctl_ip.u4_num_cores = mNumCores;\n+  s_ctl_ip.u4_size = sizeof(ihevcd_cxa_ctl_set_num_cores_ip_t);\n+  s_ctl_op.u4_size = sizeof(ihevcd_cxa_ctl_set_num_cores_op_t);\n+\n+  ivd_api_function(mCodec, (void *)&s_ctl_ip, (void *)&s_ctl_op);\n+}\n+\n+void Codec::setParams(IVD_VIDEO_DECODE_MODE_T mode) {\n+  ivd_ctl_set_config_ip_t s_ctl_ip;\n+  ivd_ctl_set_config_op_t s_ctl_op;\n+\n+  s_ctl_ip.u4_disp_wd = 0;\n+  s_ctl_ip.e_frm_skip_mode = IVD_SKIP_NONE;\n+  s_ctl_ip.e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;\n+  s_ctl_ip.e_vid_dec_mode = mode;\n+  s_ctl_ip.e_cmd = IVD_CMD_VIDEO_CTL;\n+  s_ctl_ip.e_sub_cmd = IVD_CMD_CTL_SETPARAMS;\n+  s_ctl_ip.u4_size = sizeof(ivd_ctl_set_config_ip_t);\n+  s_ctl_op.u4_size = sizeof(ivd_ctl_set_config_op_t);\n+\n+  ivd_api_function(mCodec, (void *)&s_ctl_ip, (void *)&s_ctl_op);\n+}\n+\n+void Codec::freeFrame() {\n+  for (int i = 0; i < mOutBufHandle.u4_num_bufs; i++) {\n+    if (mOutBufHandle.pu1_bufs[i]) {\n+      free(mOutBufHandle.pu1_bufs[i]);\n+      mOutBufHandle.pu1_bufs[i] = nullptr;\n+    }\n+  }\n+}\n+\n+void Codec::allocFrame() {\n+  size_t sizes[4] = {0};\n+  size_t num_bufs = 0;\n+\n+  freeFrame();\n+\n+  memset(&mOutBufHandle, 0, sizeof(mOutBufHandle));\n+\n+  switch (mColorFormat) {\n+    case IV_YUV_420SP_UV:\n+      [[fallthrough]];\n+    case IV_YUV_420SP_VU:\n+      sizes[0] = mWidth * mHeight;\n+      sizes[1] = mWidth * mHeight >> 1;\n+      num_bufs = 2;\n+      break;\n+    case IV_YUV_422ILE:\n+      sizes[0] = mWidth * mHeight * 2;\n+      num_bufs = 1;\n+      break;\n+    case IV_RGB_565:\n+      sizes[0] = mWidth * mHeight * 2;\n+      num_bufs = 1;\n+      break;\n+    case IV_RGBA_8888:\n+      sizes[0] = mWidth * mHeight * 4;\n+      num_bufs = 1;\n+      break;\n+    case IV_YUV_420P:\n+      [[fallthrough]];\n+    default:\n+      sizes[0] = mWidth * mHeight;\n+      sizes[1] = mWidth * mHeight >> 2;\n+      sizes[2] = mWidth * mHeight >> 2;\n+      num_bufs = 3;\n+      break;\n+  }\n+  mOutBufHandle.u4_num_bufs = num_bufs;\n+  for (int i = 0; i < num_bufs; i++) {\n+    mOutBufHandle.u4_min_out_buf_size[i] = sizes[i];\n+    mOutBufHandle.pu1_bufs[i] = (UWORD8 *)memalign(16, sizes[i]);\n+  }\n+}\n+\n+void Codec::decodeHeader(const uint8_t *data, size_t size) {\n+  setParams(IVD_DECODE_HEADER);\n+\n+  while (size > 0) {\n+    IV_API_CALL_STATUS_T ret;\n+    ivd_video_decode_ip_t dec_ip;\n+    ivd_video_decode_op_t dec_op;\n+    size_t bytes_consumed;\n+\n+    memset(&dec_ip, 0, sizeof(dec_ip));\n+    memset(&dec_op, 0, sizeof(dec_op));\n+\n+    dec_ip.e_cmd = IVD_CMD_VIDEO_DECODE;\n+    dec_ip.u4_ts = 0;\n+    dec_ip.pv_stream_buffer = (void *)data;\n+    dec_ip.u4_num_Bytes = size;\n+    dec_ip.u4_size = sizeof(ivd_video_decode_ip_t);\n+    dec_op.u4_size = sizeof(ivd_video_decode_op_t);\n+\n+    ret = ivd_api_function(mCodec, (void *)&dec_ip, (void *)&dec_op);\n+\n+    bytes_consumed = dec_op.u4_num_bytes_consumed;\n+    /* If no bytes are consumed, then consume 4 bytes to ensure fuzzer proceeds\n+     * to feed next data */\n+    if (!bytes_consumed) bytes_consumed = 4;\n+\n+    bytes_consumed = std::min(size, bytes_consumed);\n+\n+    data += bytes_consumed;\n+    size -= bytes_consumed;\n+\n+    mWidth = std::min(dec_op.u4_pic_wd, (UWORD32)10240);\n+    mHeight = std::min(dec_op.u4_pic_ht, (UWORD32)10240);\n+\n+    /* Break after successful header decode */\n+    if (mWidth && mHeight) {\n+      break;\n+    }\n+  }\n+  /* if width / height are invalid, set them to defaults */\n+  if (!mWidth) mWidth = 1920;\n+  if (!mHeight) mHeight = 1088;\n+}\n+\n+IV_API_CALL_STATUS_T Codec::decodeFrame(const uint8_t *data, size_t size,\n+                                        size_t *bytesConsumed) {\n+  IV_API_CALL_STATUS_T ret;\n+  ivd_video_decode_ip_t dec_ip;\n+  ivd_video_decode_op_t dec_op;\n+\n+  memset(&dec_ip, 0, sizeof(dec_ip));\n+  memset(&dec_op, 0, sizeof(dec_op));\n+\n+  dec_ip.e_cmd = IVD_CMD_VIDEO_DECODE;\n+  dec_ip.u4_ts = 0;\n+  dec_ip.pv_stream_buffer = (void *)data;\n+  dec_ip.u4_num_Bytes = size;\n+  dec_ip.u4_size = sizeof(ivd_video_decode_ip_t);\n+  dec_ip.s_out_buffer = mOutBufHandle;\n+\n+  dec_op.u4_size = sizeof(ivd_video_decode_op_t);\n+\n+  ret = ivd_api_function(mCodec, (void *)&dec_ip, (void *)&dec_op);\n+\n+  /* In case of change in resolution, reset codec and feed the same data again\n+   */\n+  if (IVD_RES_CHANGED == (dec_op.u4_error_code & 0xFF)) {\n+    resetCodec();\n+    ret = ivd_api_function(mCodec, (void *)&dec_ip, (void *)&dec_op);\n+  }\n+  *bytesConsumed = dec_op.u4_num_bytes_consumed;\n+\n+  /* If no bytes are consumed, then consume 4 bytes to ensure fuzzer proceeds\n+   * to feed next data */\n+  if (!*bytesConsumed) *bytesConsumed = 4;\n+\n+  if (mWidth != dec_op.u4_pic_wd || mHeight != dec_op.u4_pic_ht) {\n+    mWidth = std::min(dec_op.u4_pic_wd, (UWORD32)10240);\n+    mHeight = std::min(dec_op.u4_pic_ht, (UWORD32)10240);\n+    allocFrame();\n+  }\n+\n+  return ret;\n+}\n+\n+extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n+  if (size < 1) {\n+    return 0;\n+  }\n+  size_t colorFormatOfst = std::min((size_t)OFFSET_COLOR_FORMAT, size - 1);\n+  size_t numCoresOfst = std::min((size_t)OFFSET_NUM_CORES, size - 1);\n+  size_t colorFormatIdx = data[colorFormatOfst] % kSupportedColorFormats;\n+  IV_COLOR_FORMAT_T colorFormat =\n+      (IV_COLOR_FORMAT_T)(supportedColorFormats[colorFormatIdx]);\n+  uint32_t numCores = (data[numCoresOfst] % kMaxCores) + 1;\n+\n+  Codec *codec = new Codec(colorFormat, numCores);\n+  codec->createCodec();\n+  codec->setCores();\n+  codec->decodeHeader(data, size);\n+  codec->setParams(IVD_DECODE_FRAME);\n+  codec->allocFrame();\n+\n+  while (size > 0) {\n+    IV_API_CALL_STATUS_T ret;\n+    size_t bytesConsumed;\n+    ret = codec->decodeFrame(data, size, &bytesConsumed);\n+\n+    bytesConsumed = std::min(size, bytesConsumed);\n+    data += bytesConsumed;\n+    size -= bytesConsumed;\n+  }\n+\n+  codec->freeFrame();\n+  codec->deleteCodec();\n+  delete codec;\n+  return 0;\n+}"
  },
  {
    "filename": "fuzzer/hevc_dec_fuzzer.dict",
    "patched_line_numbers": [
    ],
    "patch": "diff --git a/fuzzer/hevc_dec_fuzzer.dict b/fuzzer/hevc_dec_fuzzer.dict\nnew file mode 100644\nindex 0000000..f436f20\n--- /dev/null\n+++ b/fuzzer/hevc_dec_fuzzer.dict\n\n@@ -0,0 +1,2 @@\n+# Start code (bytes 0-3)\n+kw1=\"\\x00\\x00\\x00\\x01\""
  }
]
