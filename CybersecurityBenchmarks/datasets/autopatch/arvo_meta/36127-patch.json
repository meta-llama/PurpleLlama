[
  {
    "filename": "Userland/Libraries/LibJS/Runtime/Temporal/AbstractOperations.cpp",
    "patched_line_numbers": [
      118,
      120,
      122,
      123,
      124,
      126,
      127,
      131,
      133,
      135,
      137,
      139,
      142,
      144,
      147,
      149,
      152,
      154,
      158,
      159,
      160,
      161,
      162,
      165,
      166,
      167,
      171,
      174,
      176,
      177,
      181,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      199,
      201,
      206,
      207,
      208,
      211,
      212,
      213,
      214,
      217,
      219,
      223,
      225,
      226,
      230,
      234,
      236,
      240,
      243,
      244,
      246,
      248,
      251,
      252,
      254,
      256,
      258,
      259,
      262,
      264,
      265,
      268,
      273,
      275,
      276,
      277,
      278,
      279,
      284
    ],
    "patch": "@@ -114,6 +114,176 @@ Value get_option(GlobalObject& global_object, Object& options, String const& pro\n     return value;\n }\n \n+// 13.8 ToTemporalRoundingMode ( normalizedOptions, fallback ), https://tc39.es/proposal-temporal/#sec-temporal-totemporalroundingmode\n+String to_temporal_rounding_mode(GlobalObject& global_object, Object& normalized_options, String const& fallback)\n+{\n+    auto& vm = global_object.vm();\n+\n+    auto option = get_option(global_object, normalized_options, \"roundingMode\", { OptionType::String }, { \"ceil\"sv, \"floor\"sv, \"trunc\"sv, \"halfExpand\"sv }, js_string(vm, fallback));\n+    if (vm.exception())\n+        return {};\n+\n+    VERIFY(option.is_string());\n+    return option.as_string().string();\n+}\n+\n+// 13.14 ToTemporalRoundingIncrement ( normalizedOptions, dividend, inclusive ), https://tc39.es/proposal-temporal/#sec-temporal-totemporalroundingincrement\n+u64 to_temporal_rounding_increment(GlobalObject& global_object, Object& normalized_options, Optional<double> dividend, bool inclusive)\n+{\n+    auto& vm = global_object.vm();\n+\n+    double maximum;\n+    // 1. If dividend is undefined, then\n+    if (!dividend.has_value()) {\n+        // a. Let maximum be +\u221e.\n+        maximum = INFINITY;\n+    }\n+    // 2. Else if inclusive is true, then\n+    else if (inclusive) {\n+        // a. Let maximum be dividend.\n+        maximum = *dividend;\n+    }\n+    // 3. Else if dividend is more than 1, then\n+    else if (*dividend > 1) {\n+        // a. Let maximum be dividend \u2212 1.\n+        maximum = *dividend - 1;\n+    }\n+    // 4. Else,\n+    else {\n+        // a. Let maximum be 1.\n+        maximum = 1;\n+    }\n+\n+    // 5. Let increment be ? GetOption(normalizedOptions, \"roundingIncrement\", \u00ab Number \u00bb, empty, 1).\n+    auto increment_value = get_option(global_object, normalized_options, \"roundingIncrement\", { OptionType::Number }, {}, Value(1));\n+    if (vm.exception())\n+        return {};\n+    VERIFY(increment_value.is_number());\n+    auto increment = increment_value.as_double();\n+\n+    // 6. If increment < 1 or increment > maximum, throw a RangeError exception.\n+    if (increment < 1 || increment > maximum) {\n+        vm.throw_exception<RangeError>(global_object, ErrorType::OptionIsNotValidValue, increment, \"roundingIncrement\");\n+        return {};\n+    }\n+\n+    // 7. Set increment to floor(\u211d(increment)).\n+    auto floored_increment = static_cast<u64>(increment);\n+\n+    // 8. If dividend is not undefined and dividend modulo increment is not zero, then\n+    if (dividend.has_value() && static_cast<u64>(*dividend) % floored_increment != 0) {\n+        // a. Throw a RangeError exception.\n+        vm.throw_exception<RangeError>(global_object, ErrorType::OptionIsNotValidValue, increment, \"roundingIncrement\");\n+        return {};\n+    }\n+\n+    // 9. Return increment.\n+    return floored_increment;\n+}\n+\n+// https://tc39.es/proposal-temporal/#table-temporal-singular-and-plural-units\n+static HashMap<StringView, StringView> plural_to_singular_units = {\n+    { \"years\"sv, \"year\"sv },\n+    { \"months\"sv, \"month\"sv },\n+    { \"weeks\"sv, \"week\"sv },\n+    { \"days\"sv, \"day\"sv },\n+    { \"hours\"sv, \"hour\"sv },\n+    { \"minutes\"sv, \"minute\"sv },\n+    { \"seconds\"sv, \"second\"sv },\n+    { \"milliseconds\"sv, \"millisecond\"sv },\n+    { \"microseconds\"sv, \"microsecond\"sv },\n+    { \"nanoseconds\"sv, \"nanosecond\"sv }\n+};\n+\n+// 13.18 ToSmallestTemporalUnit ( normalizedOptions, disallowedUnits, fallback ), https://tc39.es/proposal-temporal/#sec-temporal-tosmallesttemporalunit\n+Optional<String> to_smallest_temporal_unit(GlobalObject& global_object, Object& normalized_options, Vector<StringView> const& disallowed_units, Optional<String> fallback)\n+{\n+    auto& vm = global_object.vm();\n+\n+    // 1. Assert: disallowedUnits does not contain fallback.\n+\n+    // 2. Let smallestUnit be ? GetOption(normalizedOptions, \"smallestUnit\", \u00ab String \u00bb, \u00ab \"year\", \"years\", \"month\", \"months\", \"week\", \"weeks\", \"day\", \"days\", \"hour\", \"hours\", \"minute\", \"minutes\", \"second\", \"seconds\", \"millisecond\", \"milliseconds\", \"microsecond\", \"microseconds\", \"nanosecond\", \"nanoseconds\" \u00bb, fallback).\n+    auto smallest_unit_value = get_option(global_object, normalized_options, \"smallestUnit\"sv, { OptionType::String }, { \"year\"sv, \"years\"sv, \"month\"sv, \"months\"sv, \"week\"sv, \"weeks\"sv, \"day\"sv, \"days\"sv, \"hour\"sv, \"hours\"sv, \"minute\"sv, \"minutes\"sv, \"second\"sv, \"seconds\"sv, \"millisecond\"sv, \"milliseconds\"sv, \"microsecond\"sv, \"microseconds\"sv, \"nanosecond\"sv, \"nanoseconds\"sv }, fallback.has_value() ? js_string(vm, *fallback) : js_undefined());\n+    if (vm.exception())\n+        return {};\n+\n+    // OPTIMIZATION: We skip the following string-only checks for the fallback to tidy up the code a bit\n+    if (smallest_unit_value.is_undefined())\n+        return {};\n+    VERIFY(smallest_unit_value.is_string());\n+    auto smallest_unit = smallest_unit_value.as_string().string();\n+\n+    // 3. If smallestUnit is in the Plural column of Table 12, then\n+    if (auto singular_unit = plural_to_singular_units.get(smallest_unit); singular_unit.has_value()) {\n+        // a. Set smallestUnit to the corresponding Singular value of the same row.\n+        smallest_unit = singular_unit.value();\n+    }\n+\n+    // 4. If disallowedUnits contains smallestUnit, then\n+    if (disallowed_units.contains_slow(smallest_unit)) {\n+        // a. Throw a RangeError exception.\n+        vm.throw_exception<RangeError>(global_object, ErrorType::OptionIsNotValidValue, smallest_unit, \"smallestUnit\");\n+        return {};\n+    }\n+\n+    // 5. Return smallestUnit.\n+    return smallest_unit;\n+}\n+\n+// 13.32 RoundNumberToIncrement ( x, increment, roundingMode )\n+BigInt* round_number_to_increment(GlobalObject& global_object, BigInt const& x, u64 increment, String const& rounding_mode)\n+{\n+    auto& heap = global_object.heap();\n+\n+    // 1. Assert: x and increment are mathematical values.\n+    // 2. Assert: roundingMode is \"ceil\", \"floor\", \"trunc\", or \"halfExpand\".\n+    VERIFY(rounding_mode == \"ceil\" || rounding_mode == \"floor\" || rounding_mode == \"trunc\" || rounding_mode == \"halfExpand\");\n+\n+    // OPTIMIZATION: If the increment is 1 the number is always rounded\n+    if (increment == 1)\n+        return js_bigint(heap, x.big_integer());\n+\n+    auto increment_big_int = Crypto::UnsignedBigInteger::create_from(increment);\n+    // 3. Let quotient be x / increment.\n+    auto division_result = x.big_integer().divided_by(increment_big_int);\n+\n+    // OPTIMIZATION: If theres no remainder there number is already rounded\n+    if (division_result.remainder == Crypto::UnsignedBigInteger { 0 })\n+        return js_bigint(heap, x.big_integer());\n+\n+    Crypto::SignedBigInteger rounded = move(division_result.quotient);\n+    // 4. If roundingMode is \"ceil\", then\n+    if (rounding_mode == \"ceil\") {\n+        // a. Let rounded be \u2212floor(\u2212quotient).\n+        if (!division_result.remainder.is_negative())\n+            rounded = rounded.plus(Crypto::UnsignedBigInteger { 1 });\n+    }\n+    // 5. Else if roundingMode is \"floor\", then\n+    else if (rounding_mode == \"floor\") {\n+        // a. Let rounded be floor(quotient).\n+        if (division_result.remainder.is_negative())\n+            rounded = rounded.minus(Crypto::UnsignedBigInteger { 1 });\n+    }\n+    // 6. Else if roundingMode is \"trunc\", then\n+    else if (rounding_mode == \"trunc\") {\n+        // a. Let rounded be the integral part of quotient, removing any fractional digits.\n+        // NOTE: This is a no-op\n+    }\n+    // 7. Else,\n+    else {\n+        // a. Let rounded be ! RoundHalfAwayFromZero(quotient).\n+        if (division_result.remainder.multiplied_by(Crypto::UnsignedBigInteger { 2 }).unsigned_value() >= increment_big_int) {\n+            if (division_result.remainder.is_negative())\n+                rounded = rounded.minus(Crypto::UnsignedBigInteger { 1 });\n+            else\n+                rounded = rounded.plus(Crypto::UnsignedBigInteger { 1 });\n+        }\n+    }\n+\n+    // 8. Return rounded \u00d7 increment.\n+    return js_bigint(heap, rounded.multiplied_by(increment_big_int));\n+}\n+\n // 13.34 ParseISODateTime ( isoString ), https://tc39.es/proposal-temporal/#sec-temporal-parseisodatetime\n Optional<ISODateTime> parse_iso_date_time(GlobalObject& global_object, [[maybe_unused]] String const& iso_string)\n {"
  },
  {
    "filename": "Userland/Libraries/LibJS/Runtime/Temporal/AbstractOperations.h",
    "patched_line_numbers": [
      22,
      23,
      24,
      25
    ],
    "patch": "@@ -19,7 +19,10 @@ enum class OptionType {\n     Number\n };\n Value get_option(GlobalObject&, Object& options, String const& property, Vector<OptionType> const& types, Vector<StringView> const& values, Value fallback);\n-\n+String to_temporal_rounding_mode(GlobalObject&, Object& normalized_options, String const& fallback);\n+u64 to_temporal_rounding_increment(GlobalObject&, Object& normalized_options, Optional<double> dividend, bool inclusive);\n+Optional<String> to_smallest_temporal_unit(GlobalObject&, Object& normalized_options, Vector<StringView> const& disallowed_units, Optional<String> fallback);\n+BigInt* round_number_to_increment(GlobalObject&, BigInt const&, u64 increment, String const& rounding_mode);\n struct ISODateTime {\n     i32 year;\n     i32 month;"
  },
  {
    "filename": "Userland/Libraries/LibJS/Runtime/Temporal/Instant.cpp",
    "patched_line_numbers": [
      157,
      161,
      163,
      165,
      168,
      170,
      173,
      175,
      178,
      180,
      183,
      185,
      188,
      190,
      194
    ],
    "patch": "@@ -153,4 +153,45 @@ i32 compare_epoch_nanoseconds(BigInt const& epoch_nanoseconds_one, BigInt const&\n     return 0;\n }\n \n+// 8.5.8 RoundTemporalInstant ( ns, increment, unit, roundingMode ), https://tc39.es/proposal-temporal/#sec-temporal-roundtemporalinstant\n+BigInt* round_temporal_instant(GlobalObject& global_object, BigInt const& nanoseconds, u64 increment, String const& unit, String const& rounding_mode)\n+{\n+    // 1. Assert: Type(ns) is BigInt.\n+\n+    u64 increment_nanoseconds;\n+    // 2. If unit is \"hour\", then\n+    if (unit == \"hour\") {\n+        // a. Let incrementNs be increment \u00d7 3.6 \u00d7 10^12.\n+        increment_nanoseconds = increment * 3600000000000;\n+    }\n+    // 3. Else if unit is \"minute\", then\n+    else if (unit == \"minute\") {\n+        // a. Let incrementNs be increment \u00d7 6 \u00d7 10^10.\n+        increment_nanoseconds = increment * 60000000000;\n+    }\n+    // 4. Else if unit is \"second\", then\n+    else if (unit == \"second\") {\n+        // a. Let incrementNs be increment \u00d7 10^9.\n+        increment_nanoseconds = increment * 1000000000;\n+    }\n+    // 5. Else if unit is \"millisecond\", then\n+    else if (unit == \"millisecond\") {\n+        // a. Let incrementNs be increment \u00d7 10^6.\n+        increment_nanoseconds = increment * 1000000;\n+    }\n+    // 6. Else if unit is \"microsecond\", then\n+    else if (unit == \"microsecond\") {\n+        // a. Let incrementNs be increment \u00d7 10^3.\n+        increment_nanoseconds = increment * 1000;\n+    }\n+    // 7. Else,\n+    else {\n+        // a. Let incrementNs be increment.\n+        increment_nanoseconds = increment;\n+    }\n+\n+    // 8. Return ! RoundNumberToIncrement(\u211d(ns), incrementNs, roundingMode).\n+    return round_number_to_increment(global_object, nanoseconds, increment_nanoseconds, rounding_mode);\n+}\n+\n }"
  },
  {
    "filename": "Userland/Libraries/LibJS/Runtime/Temporal/Instant.h",
    "patched_line_numbers": [
      44
    ],
    "patch": "@@ -41,5 +41,6 @@ Instant* create_temporal_instant(GlobalObject&, BigInt& nanoseconds, FunctionObj\n Instant* to_temporal_instant(GlobalObject&, Value item);\n BigInt* parse_temporal_instant(GlobalObject&, String const& iso_string);\n i32 compare_epoch_nanoseconds(BigInt const&, BigInt const&);\n+BigInt* round_temporal_instant(GlobalObject&, BigInt const& nanoseconds, u64 increment, String const& unit, String const& rounding_mode);\n \n }"
  },
  {
    "filename": "Userland/Libraries/LibJS/Runtime/Temporal/InstantPrototype.cpp",
    "patched_line_numbers": [
      9,
      37,
      128,
      132,
      133,
      134,
      137,
      138,
      139,
      142,
      143,
      144,
      147,
      148,
      149,
      152,
      155,
      156,
      157,
      159,
      161,
      163,
      166,
      168,
      171,
      173,
      176,
      178,
      181,
      183,
      186,
      188,
      190,
      194,
      195,
      196,
      199,
      200,
      201,
      204
    ],
    "patch": "@@ -6,6 +6,7 @@\n \n #include <LibCrypto/BigInt/UnsignedBigInteger.h>\n #include <LibJS/Runtime/GlobalObject.h>\n+#include <LibJS/Runtime/Temporal/AbstractOperations.h>\n #include <LibJS/Runtime/Temporal/Instant.h>\n #include <LibJS/Runtime/Temporal/InstantPrototype.h>\n \n@@ -33,6 +34,7 @@ void InstantPrototype::initialize(GlobalObject& global_object)\n \n     u8 attr = Attribute::Writable | Attribute::Configurable;\n     define_native_function(vm.names.valueOf, value_of, 0, attr);\n+    define_native_function(vm.names.round, round, 1, attr);\n     define_native_function(vm.names.equals, equals, 1, attr);\n }\n \n@@ -122,6 +124,86 @@ JS_DEFINE_NATIVE_FUNCTION(InstantPrototype::epoch_nanoseconds_getter)\n     return &ns;\n }\n \n+// 8.3.11 Temporal.Instant.prototype.round ( options )\n+JS_DEFINE_NATIVE_FUNCTION(InstantPrototype::round)\n+{\n+    // 1. Let instant be the this value.\n+    // 2. Perform ? RequireInternalSlot(instant, [[InitializedTemporalInstant]]).\n+    auto* instant = typed_this(global_object);\n+    if (vm.exception())\n+        return {};\n+\n+    // 3. Set options to ? GetOptionsObject(options).\n+    auto* options = get_options_object(global_object, vm.argument(0));\n+    if (vm.exception())\n+        return {};\n+\n+    // 4. Let smallestUnit be ? ToSmallestTemporalUnit(options, \u00ab \"year\", \"month\", \"week\", \"day\" \u00bb, undefined).\n+    auto smallest_unit_value = to_smallest_temporal_unit(global_object, *options, { \"year\"sv, \"month\"sv, \"week\"sv, \"day\"sv }, {});\n+    if (vm.exception())\n+        return {};\n+\n+    // 5. If smallestUnit is undefined, throw a RangeError exception.\n+    if (!smallest_unit_value.has_value()) {\n+        vm.throw_exception<RangeError>(global_object, ErrorType::OptionIsNotValidValue, vm.names.undefined.as_string(), \"smallestUnit\");\n+        return {};\n+    }\n+    // At this point smallest_unit_value can only be a string\n+    auto& smallest_unit = *smallest_unit_value;\n+\n+    // 6. Let roundingMode be ? ToTemporalRoundingMode(options, \"halfExpand\").\n+    auto rounding_mode = to_temporal_rounding_mode(global_object, *options, \"halfExpand\");\n+    if (vm.exception())\n+        return {};\n+\n+    double maximum;\n+    // 7. If smallestUnit is \"hour\", then\n+    if (smallest_unit == \"hour\"sv) {\n+        // a. Let maximum be 24.\n+        maximum = 24;\n+    }\n+    // 8. Else if smallestUnit is \"minute\", then\n+    else if (smallest_unit == \"minute\"sv) {\n+        // a. Let maximum be 1440.\n+        maximum = 1440;\n+    }\n+    // 9. Else if smallestUnit is \"second\", then\n+    else if (smallest_unit == \"second\"sv) {\n+        // a. Let maximum be 86400.\n+        maximum = 86400;\n+    }\n+    // 10. Else if smallestUnit is \"millisecond\", then\n+    else if (smallest_unit == \"millisecond\"sv) {\n+        // a. Let maximum be 8.64 \u00d7 10^7.\n+        maximum = 86400000;\n+    }\n+    // 11. Else if smallestUnit is \"microsecond\", then\n+    else if (smallest_unit == \"microsecond\"sv) {\n+        // a. Let maximum be 8.64 \u00d7 10^10.\n+        maximum = 86400000000;\n+    }\n+    // 12. Else,\n+    else {\n+        // a. Assert: smallestUnit is \"nanosecond\".\n+        VERIFY(smallest_unit == \"nanosecond\"sv);\n+        // b. Let maximum be 8.64 \u00d7 10^13.\n+        maximum = 86400000000000;\n+    }\n+\n+    // 13. Let roundingIncrement be ? ToTemporalRoundingIncrement(options, maximum, true).\n+    auto rounding_increment = to_temporal_rounding_increment(global_object, *options, maximum, true);\n+    if (vm.exception())\n+        return {};\n+\n+    // 14. Let roundedNs be ? RoundTemporalInstant(instant.[[Nanoseconds]], roundingIncrement, smallestUnit, roundingMode).\n+    auto* rounded_ns = round_temporal_instant(global_object, instant->nanoseconds(), rounding_increment, smallest_unit, rounding_mode);\n+    if (vm.exception())\n+        return {};\n+\n+    // 15. Return ? CreateTemporalInstant(roundedNs).\n+    return create_temporal_instant(global_object, *rounded_ns);\n+}\n+\n // 8.3.12 Temporal.Instant.prototype.equals ( other ), https://tc39.es/proposal-temporal/#sec-temporal.instant.prototype.equals\n JS_DEFINE_NATIVE_FUNCTION(InstantPrototype::equals)\n {"
  },
  {
    "filename": "Userland/Libraries/LibJS/Runtime/Temporal/InstantPrototype.h",
    "patched_line_numbers": [
      27
    ],
    "patch": "@@ -24,6 +24,7 @@ class InstantPrototype final : public Object {\n     JS_DECLARE_NATIVE_FUNCTION(epoch_microseconds_getter);\n     JS_DECLARE_NATIVE_FUNCTION(epoch_nanoseconds_getter);\n \n+    JS_DECLARE_NATIVE_FUNCTION(round);\n     JS_DECLARE_NATIVE_FUNCTION(equals);\n     JS_DECLARE_NATIVE_FUNCTION(value_of);\n };"
  },
  {
    "filename": "Userland/Libraries/LibJS/Tests/builtins/Temporal/Instant/Instant.prototype.round.js",
    "patched_line_numbers": [
    ],
    "patch": "@@ -0,0 +1,62 @@\n+describe(\"correct behavior\", () => {\n+    test(\"basic functionality\", () => {\n+        const instant = new Temporal.Instant(1111111111111n);\n+        expect(instant.round({ smallestUnit: \"second\" }).epochNanoseconds).toBe(1111000000000n);\n+        expect(\n+            instant.round({ smallestUnit: \"second\", roundingMode: \"ceil\" }).epochNanoseconds\n+        ).toBe(1112000000000n);\n+        expect(\n+            instant.round({ smallestUnit: \"minute\", roundingIncrement: 30, roundingMode: \"floor\" })\n+                .epochNanoseconds\n+        ).toBe(0n);\n+        expect(\n+            instant.round({\n+                smallestUnit: \"minute\",\n+                roundingIncrement: 30,\n+                roundingMode: \"halfExpand\",\n+            }).epochNanoseconds\n+        ).toBe(1800000000000n);\n+    });\n+});\n+\n+test(\"errors\", () => {\n+    test(\"this value must be a Temporal.Instant object\", () => {\n+        expect(() => {\n+            Temporal.Instant.prototype.round.call(\"foo\", {});\n+        }).toThrowWithMessage(TypeError, \"Not a Temporal.Instant\");\n+    });\n+\n+    test(\"invalid rounding mode\", () => {\n+        expect(() => {\n+            const instant = new Temporal.Instant(1n);\n+            instant.round({ smallestUnit: \"second\", roundingMode: \"serenityOS\" });\n+        }).toThrowWithMessage(RangeError, \"is not a valid value for option roundingMode\");\n+    });\n+\n+    test(\"invalid smallest unit\", () => {\n+        expect(() => {\n+            const instant = new Temporal.Instant(1n);\n+            instant.round({ smallestUnit: \"serenityOS\" });\n+        }).toThrowWithMessage(RangeError, \"is not a valid value for option smallestUnit\");\n+    });\n+\n+    test(\"increment may not be NaN\", () => {\n+        expect(() => {\n+            const instant = new Temporal.Instant(1n);\n+            instant.round({ smallestUnit: \"second\", roundingIncrement: NaN });\n+        }).toThrowWithMessage(RangeError, \"is not a valid value for option roundingIncrement\");\n+    });\n+\n+    test(\"increment may smaller than 1 or larger than maximum\", () => {\n+        const instant = new Temporal.Instant(1n);\n+        expect(() => {\n+            instant.round({ smallestUnit: \"second\", roundingIncrement: -1 });\n+        }).toThrowWithMessage(RangeError, \"is not a valid value for option roundingIncrement\");\n+        expect(() => {\n+            instant.round({ smallestUnit: \"second\", roundingIncrement: 0 });\n+        }).toThrowWithMessage(RangeError, \"is not a valid value for option roundingIncrement\");\n+        expect(() => {\n+            instant.round({ smallestUnit: \"second\", roundingIncrement: Infinity });\n+        }).toThrowWithMessage(RangeError, \"is not a valid value for option roundingIncrement\");\n+    });\n+});"
  }
]
